class ConnectionManager{constructor(){this.isConnected=!1,this.contextValid=!0,this.messageQueue=[],this.connectionAttempts=0,this.maxRetries=5,this.retryDelay=1e3,this.healthCheckInterval=null,this.reconnectTimeout=null,this.listeners=new Map,this.onConnectionChange=null,this.onContextInvalid=null,this.init()}async init(){await this.validateContext(),this.contextValid&&(await this.establishConnection(),this.startHealthCheck())}async validateContext(){try{if(!chrome)throw new Error("Chrome object not available");if(!chrome.runtime)throw new Error("Chrome runtime not available");if(!chrome.runtime.id&&(await new Promise(e=>setTimeout(e,100)),!chrome.runtime.id))throw new Error("Extension context invalidated - no runtime ID");try{const e=chrome.runtime.getURL("manifest.json");if(!e||!e.startsWith("chrome-extension://"))throw new Error("Cannot access extension URLs")}catch(e){if(chrome.runtime.lastError||e.message.includes("Extension context invalidated"))throw new Error("Extension context invalidated during API test");console.warn("Runtime API test failed but context may still be valid:",e.message)}return this.contextValid=!0,!0}catch(e){return e.message.includes("Extension context invalidated")||e.message.includes("Chrome runtime not available")?(console.warn("Extension context validation failed:",e.message),this.contextValid=!1,this.handleContextInvalidation()):console.debug("Context validation warning (may be transient):",e.message),!1}}async establishConnection(){if(!this.contextValid)return!1;try{const e=await this.sendMessage({type:"CONNECTION_TEST",timestamp:Date.now()},{skipQueue:!0});if(e&&e.success)return this.isConnected=!0,this.connectionAttempts=0,await this.flushMessageQueue(),this.notifyConnectionChange(!0),console.log("✅ Connection established with background service"),!0;throw new Error("Invalid response from background service")}catch(e){return console.warn("Failed to establish connection:",e.message),this.isConnected=!1,this.scheduleReconnection(),!1}}async sendMessage(e,t={}){const{skipQueue:n=!1,timeout:i=5e3}=t;if(!this.contextValid)throw new Error("Extension context is invalid");if(!this.isConnected&&!n)return this.queueMessage(e,t);try{return await this.executeMessage(e,i)}catch(i){if(this.isContextError(i))throw await this.handleContextInvalidation(),new Error("Extension context invalidated during message send");if(this.isConnectionError(i)){if(this.isConnected=!1,!n)return this.queueMessage(e,t);throw i}throw i}}async executeMessage(e,t){return new Promise((n,i)=>{const s=setTimeout(()=>{i(new Error("Message timeout"))},t);chrome.runtime.sendMessage(e,e=>{clearTimeout(s),chrome.runtime.lastError?i(new Error(chrome.runtime.lastError.message)):n(e)})})}queueMessage(e,t){return new Promise((n,i)=>{if(this.messageQueue.push({message:e,options:t,resolve:n,reject:i,timestamp:Date.now(),priority:t.priority||"normal"}),this.messageQueue.sort((e,t)=>{const n={high:3,normal:2,low:1};return n[t.priority]-n[e.priority]}),this.messageQueue.length>100){this.messageQueue.splice(50).forEach(e=>{e.reject(new Error("Message queue overflow"))})}console.log(`📬 Message queued (${this.messageQueue.length} pending): ${e.type}`)})}async flushMessageQueue(){if(0===this.messageQueue.length)return;console.log(`📤 Flushing ${this.messageQueue.length} queued messages`);const e=[...this.messageQueue];this.messageQueue=[];for(const t of e)try{const e=await this.executeMessage(t.message,5e3);t.resolve(e)}catch(n){if(this.isConnectionError(n)){this.messageQueue.unshift(t,...e.slice(e.indexOf(t)+1));break}t.reject(n)}}scheduleReconnection(){if(this.reconnectTimeout)return;this.connectionAttempts++;const e=Math.min(this.retryDelay*Math.pow(2,this.connectionAttempts-1),3e4);console.log(`🔄 Scheduling reconnection attempt ${this.connectionAttempts}/${this.maxRetries} in ${e}ms`),this.reconnectTimeout=setTimeout(async()=>{this.reconnectTimeout=null,this.connectionAttempts<this.maxRetries?(await this.validateContext(),this.contextValid&&await this.establishConnection()):(console.error("❌ Max reconnection attempts reached. Running in offline mode."),this.notifyConnectionChange(!1))},e)}startHealthCheck(){this.healthCheckInterval||(this.healthCheckInterval=setInterval(async()=>{if(this.contextValid)try{await this.validateContext(),this.contextValid&&this.isConnected?await this.sendMessage({type:"HEALTH_CHECK",timestamp:Date.now()},{skipQueue:!0,timeout:2e3}):this.contextValid&&!this.isConnected&&await this.establishConnection()}catch(e){console.warn("Health check failed:",e.message),this.isContextError(e)?await this.handleContextInvalidation():(this.isConnected=!1,this.scheduleReconnection())}else this.stopHealthCheck()},15e3))}stopHealthCheck(){this.healthCheckInterval&&(clearInterval(this.healthCheckInterval),this.healthCheckInterval=null)}async handleContextInvalidation(){const e=0===this.connectionAttempts&&chrome&&chrome.runtime;e?console.info("🔄 Extension context temporarily invalid (likely during reload)"):console.warn("🚨 Extension context invalidated - switching to offline mode"),this.contextValid=!1,this.isConnected=!1,this.stopHealthCheck(),this.reconnectTimeout&&(clearTimeout(this.reconnectTimeout),this.reconnectTimeout=null),e?console.info("💾 Preserving message queue for post-reload reconnection"):(this.messageQueue.forEach(e=>{e.reject(new Error("Extension context invalidated"))}),this.messageQueue=[]),e||this.cleanup(),this.notifyConnectionChange(!1),this.onContextInvalid&&this.onContextInvalid(e)}isContextError(e){return["Extension context invalidated","receiving end does not exist","message port closed","runtime.lastError"].some(t=>e.message.toLowerCase().includes(t.toLowerCase()))}isConnectionError(e){return["timeout","connection","network","unavailable"].some(t=>e.message.toLowerCase().includes(t.toLowerCase()))}notifyConnectionChange(e){this.onConnectionChange&&this.onConnectionChange(e),"undefined"!=typeof window&&window.dispatchEvent(new CustomEvent("connectionStateChange",{detail:{connected:e,contextValid:this.contextValid}}))}addListener(e,t,n,i){const s=`${e.constructor.name}-${t}-${Date.now()}`;return e.addEventListener(t,n,i),this.listeners.set(s,()=>{e.removeEventListener(t,n,i)}),s}removeListener(e){const t=this.listeners.get(e);t&&(t(),this.listeners.delete(e))}cleanup(){this.stopHealthCheck(),this.reconnectTimeout&&(clearTimeout(this.reconnectTimeout),this.reconnectTimeout=null),this.listeners.forEach(e=>e()),this.listeners.clear(),console.log("🧹 Connection manager cleanup completed")}getStatus(){return{connected:this.isConnected,contextValid:this.contextValid,queuedMessages:this.messageQueue.length,connectionAttempts:this.connectionAttempts}}}"undefined"!=typeof module&&module.exports?module.exports=ConnectionManager:window.ConnectionManager=ConnectionManager;