class FallbackStorage{constructor(){this.dbName="AttentionTrainerFallback",this.dbVersion=1,this.db=null,this.initialized=!1,this.storeName="analytics",this.settingsStore="settings"}async init(){if(this.initialized)return!0;try{return new Promise((t,e)=>{const r=indexedDB.open(this.dbName,this.dbVersion);r.onerror=()=>{console.error("Failed to open IndexedDB:",r.error),e(r.error)},r.onsuccess=()=>{this.db=r.result,this.initialized=!0,console.log("âœ… Fallback storage initialized"),t(!0)},r.onupgradeneeded=t=>{const e=t.target.result;if(!e.objectStoreNames.contains(this.storeName)){const t=e.createObjectStore(this.storeName,{keyPath:"key"});t.createIndex("domain","domain",{unique:!1}),t.createIndex("date","date",{unique:!1}),t.createIndex("timestamp","timestamp",{unique:!1})}e.objectStoreNames.contains(this.settingsStore)||e.createObjectStore(this.settingsStore,{keyPath:"key"}),console.log("ðŸ“Š IndexedDB schema created")}})}catch(t){return console.error("IndexedDB initialization failed:",t),!1}}async storeAnalytics(t,e,r){await this.ensureInitialized();const o={key:`analytics_${t}_${e}`,domain:t,date:e,data:r,timestamp:Date.now()};return this.writeToStore(this.storeName,o)}async getAnalytics(t=null,e=null){return await this.ensureInitialized(),new Promise((r,o)=>{const s=this.db.transaction([this.storeName],"readonly").objectStore("analytics"),a=[];let i;if(t){const e=s.index("domain");i=e.openCursor(IDBKeyRange.only(t))}else i=s.openCursor();i.onsuccess=t=>{const o=t.target.result;if(o){const t=o.value;if(e){const r=new Date(t.date);r>=e.start&&r<=e.end&&a.push(t)}else a.push(t);o.continue()}else r(a)},i.onerror=()=>{console.error("Failed to read analytics:",i.error),o(i.error)}})}async storeSetting(t,e){await this.ensureInitialized();const r={key:t,value:e,timestamp:Date.now()};return this.writeToStore(this.settingsStore,r)}async getSetting(t){return await this.ensureInitialized(),new Promise((e,r)=>{const o=this.db.transaction([this.settingsStore],"readonly").objectStore(this.settingsStore).get(t);o.onsuccess=()=>{const t=o.result;e(t?t.value:null)},o.onerror=()=>{console.error("Failed to read setting:",o.error),r(o.error)}})}async getAllSettings(){return await this.ensureInitialized(),new Promise((t,e)=>{const r=this.db.transaction([this.settingsStore],"readonly").objectStore(this.settingsStore).getAll();r.onsuccess=()=>{const e=r.result||[],o={};e.forEach(t=>{o[t.key]=t.value}),t(o)},r.onerror=()=>{console.error("Failed to read all settings:",r.error),e(r.error)}})}async syncToChrome(){if(!chrome?.storage?.local)return console.warn("Chrome storage not available for sync"),!1;try{await this.ensureInitialized();const t=await this.getAnalytics();if(t.length>0){const e=await this.getChromeAnalytics();t.forEach(t=>{const{domain:r,date:o,data:s}=t;e.dailyStats||(e.dailyStats={}),e.dailyStats[o]||(e.dailyStats[o]={}),e.dailyStats[o][r]?Object.assign(e.dailyStats[o][r],s):e.dailyStats[o][r]=s}),await chrome.storage.local.set({analytics:e}),console.log("âœ… Analytics data synced to Chrome storage")}const e=await this.getAllSettings();return Object.keys(e).length>0&&(await chrome.storage.local.set(e),console.log("âœ… Settings synced to Chrome storage")),!0}catch(t){return console.error("Failed to sync to Chrome storage:",t),!1}}async importFromChrome(){if(!chrome?.storage?.local)return console.warn("Chrome storage not available for import"),!1;try{await this.ensureInitialized();const t=await chrome.storage.local.get(["analytics"]);if(t.analytics?.dailyStats){const e=t.analytics.dailyStats;for(const[t,r]of Object.entries(e))for(const[e,o]of Object.entries(r))await this.storeAnalytics(e,t,o);console.log("âœ… Analytics imported from Chrome storage")}const e=await chrome.storage.local.get();for(const[t,r]of Object.entries(e))"analytics"!==t&&await this.storeSetting(t,r);return console.log("âœ… Settings imported from Chrome storage"),!0}catch(t){return console.error("Failed to import from Chrome storage:",t),!1}}async cleanup(t=90){await this.ensureInitialized();const e=new Date;e.setDate(e.getDate()-t);const r=e.getTime();return new Promise((t,e)=>{const o=this.db.transaction([this.storeName],"readwrite").objectStore(this.storeName).index("timestamp").openCursor(IDBKeyRange.upperBound(r));let s=0;o.onsuccess=e=>{const r=e.target.result;r?(r.delete(),s++,r.continue()):(console.log(`ðŸ§¹ Cleaned up ${s} old fallback records`),t(s))},o.onerror=()=>{console.error("Failed to cleanup old data:",o.error),e(o.error)}})}async getStats(){await this.ensureInitialized();return{analyticsRecords:await this.getRecordCount(this.storeName),settingsRecords:await this.getRecordCount(this.settingsStore),initialized:this.initialized,dbName:this.dbName,dbVersion:this.dbVersion}}async ensureInitialized(){if(this.initialized||await this.init(),!this.initialized)throw new Error("Fallback storage not available")}async writeToStore(t,e){return new Promise((r,o)=>{const s=this.db.transaction([t],"readwrite").objectStore(t).put(e);s.onsuccess=()=>r(!0),s.onerror=()=>{console.error("Failed to write to store:",s.error),o(s.error)}})}async getRecordCount(t){return new Promise((e,r)=>{const o=this.db.transaction([t],"readonly").objectStore(t).count();o.onsuccess=()=>e(o.result),o.onerror=()=>{console.error("Failed to count records:",o.error),r(o.error)}})}async getChromeAnalytics(){try{return(await chrome.storage.local.get(["analytics"])).analytics||{dailyStats:{},interventions:[]}}catch(t){return{dailyStats:{},interventions:[]}}}async clear(){return await this.ensureInitialized(),new Promise((t,e)=>{const r=this.db.transaction([this.storeName,this.settingsStore],"readwrite");r.objectStore(this.storeName).clear(),r.objectStore(this.settingsStore).clear();r.oncomplete=()=>{console.log("ðŸ§¹ All fallback storage cleared"),t(!0)},r.onerror=()=>{console.error("Failed to clear fallback storage:",r.error),e(r.error)}})}}"undefined"!=typeof module&&module.exports?module.exports=FallbackStorage:window.FallbackStorage=FallbackStorage;